{
  "name": "kaiseki",
  "description": "A Parse.com REST API Client for Node.js",
  "version": "0.4.0",
  "homepage": "https://github.com/shiki/kaiseki",
  "private": false,
  "author": {
    "name": "BJ Basa√±es",
    "email": "shikishiji@gmail.com",
    "url": "Shiki"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/shiki/kaiseki.git"
  },
  "main": "./index.js",
  "dependencies": {
    "request": "2.11.4",
    "underscore": "1.4.0",
    "mime": "1.2.7"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "async": "*"
  },
  "engines": {
    "node": "*"
  },
  "readme": "Kaiseki\n=============\n\nA Parse.com [REST API](https://parse.com/docs/rest) client for Node.js\n\n\n\nInstalling\n-------------\n\n * Install through npm:\n\n        npm install kaiseki\n\n * Or in your `package.json`:\n\n        \"dependencies\": {\n          \"kaiseki\": \"*\",\n          ...\n        }\n Then:\n\n        npm install\n\n * Or you can just download the files and put it in your project.\n\n\n\nUsage\n-------------\n\nYou might want to read about the [REST API](https://parse.com/docs/rest) first before diving in.\n\n### Setup\n\n    // the class\n    var Kaiseki = require('kaiseki');\n\n    // instantiate\n    var APP_ID = '<your-Parse-application-id>';\n    var REST_API_KEY = '<your-Parse-REST-API-key>';\n    var kaiseki = new Kaiseki(APP_ID, REST_API_KEY);\n\n    // use it\n    kaiseki.getObjects(...);\n\n### Callbacks\n\nAll callbacks should follow this format: `function(error, response, body, success) { ... }`. This is because Kaiseki is based on [Request](https://github.com/mikeal/request) and I thought it would be best to pass the same callback parameters. The `error` and `response` parameters are passed as is. On most methods, `body` is changed and parsed from JSON for your convenience.\n\n * __error__: If there's an error during the request (e.g. no internet connection), this will not be empty. Note that if the API returns a `statusCode` that is not `2xx`, it is not marked as an error.\n\n * __response__: You can check lots of info about the request in here. For example, the REST API will return a `response.statusCode` value of `4xx` on failures. In these cases, the API will still return a JSON object containing the fields `code` and `error`. You can get this in the `body` parameter.\n\n        { \"code\": 105,\n          \"error\": \"invalid field name: bl!ng\" }\n\n Read more about the Response format [here](https://parse.com/docs/rest#general-responses).\n\n * __body__: On successful requests, this will be an object or array depending on the method called.\n\n * __success__: A convenience parameter, this is a boolean indicating if the request was a success.\n\n\n### Users\n\n#### createUser (data, callback)\n\nThis will pass to `body` whatever you passed in `data` plus the returned `createdAt` and `sessionToken` fields.\n\n    var userInfo = {\n      // required\n      username: 'maricris',\n      password: 'whew',\n\n      name: 'Maricris',\n      gender: 'female',\n      nickname: 'Kit'\n    };\n\n    kaiseki.createUser(userInfo, function(err, res, body) {\n      console.log('user created with session token = ', body.sessionToken);\n      console.log('object id = ', body.objectId);\n    });\n\n#### getUser (objectId, params, callback)\n\nGets a user info based on the `objectId` (user id). The `params` is currently unused but is there for a\nfuture use. You can pass in the callback function as the second parameter.\n\n    kaiseki.getUser('<object-id>', function(err, res, body) {\n      console.log('user info = ', body);\n    });\n\n#### loginUser (username, password, callback)\n\nLog in a user. This will give you a user's `sessionToken` that you can use in `updateUser` and `deleteUser`, and other API calls that may need a `sessionToken`.\n\n    kaiseki.loginUser('username', 'my secret password', function(err, res, body) {\n      console.log('user logged in with session token = ', body.sessionToken);\n    });\n\n#### updateUser (objectId, data, callback)\n\nUpdates a user object (if that wasn't obvious). This requires a sessionToken received from `loginUser` or `createUser`. If successful, body will contain the `updatedAt` value.\n\n    kaiseki.sessionToken = 'le session token';\n    kaiseki.updateUser({name: 'new name'}, function(err, res, body) {\n      console.log('updated at = ', body.updatedAt);\n    });\n\n#### deleteUser (objectId, data, callback)\n\nDeletes a user. Like `updateUser()`, this needs a `sessionToken`.\n\n    kaiseki.sessionToken = 'le session token';\n    kaiseki.deleteUser('<object-id>', function(err, res, body) {\n      if (res.statusCode == 200)\n        console.log('deleted!');\n      else\n        console.log('failed!');\n    });\n\n#### getUsers (params, callback)\n\nReturns an array of users. The `params` parameter can be an object containing the query options as described [here](https://parse.com/docs/rest#queries-basic). Note that unlike the Parse API Doc, you do not have to pass in strings for the parameter values. This is all taken care of for you.\n\nIf you do not want to pass in some query parameters, you can set the callback as the first parameter.\n\nThe `body` in the callback is an array of the returned objects.\n\n    // get all users (no parameters)\n    kaiseki.getUsers(function(err, res, body) {\n      console.log('all users = ', body);\n    });\n\n    // query with parameters\n    var params = {\n      where: { gender: \"female\" },\n      order: '-name'\n    };\n    kaiseki.getUsers(params, function(err, res, body) {\n      console.log('female users = ', body);\n    });\n\n#### requestPasswordReset (email, callback)\n\nJust provide an email and this function will send the user an email to reset their password\n\n    kaiseki.requestPasswordReset('email@mail.com', function(err, res, body, success) {\n      if (success) {\n        console.log('Successfully Sent Password Reset');\n      } else {\n        console.log('Error: ', err, body);\n      }\n    });\n\n### Objects\n\nObject methods are similar to the User methods except that Object methods require you to specify the Parse class name. Class names are generally passed as the first parameter.\n\n#### createObject (className, data, callback)\n\nCreates an object and passes to `body` whatever you passed in `data` plus the returned `createdAt` field.\n\n    var dog = {\n      name: 'Prince',\n      breed: 'Pomeranian'\n    };\n    var className = 'Dogs';\n\n    kaiseki.createObject(className, dog, function(err, res, body) {\n      console.log('object created = ', body);\n      console.log('object id = ', body.objectId);\n    });\n\n#### getObject (className, objectId, params, callback)\n\nGets an object based on the `objectId`. The `params` is currently unused but is there for a future use. You can pass in the callback function as the second parameter.\n\n    kaiseki.getObject('Dogs', '<object-id>', function(err, res, body) {\n      console.log('found object = ', body);\n    });\n\n#### updateObject (className, objectId, data, callback)\n\nUpdates an object. If successful, body will contain the `updatedAt` value.\n\n    kaiseki.updateObject({name: 'new object name'}, function(err, res, body) {\n      console.log('object updated at = ', body.updatedAt);\n    });\n\n#### deleteObject (className, objectId, callback)\n\nDeletes an object. The REST API does not seem to return anything in the body so it's best to check for `res.statusCode` if the operation was successful.\n\n    kaiseki.deleteObject('<object-id>', function(err, res, body) {\n      if (res.statusCode == 200)\n        console.log('deleted!');\n      else\n        console.log('failed!');\n    });\n\n#### getObjects (className, params, callback)\n\nReturns an array of objects in the class name. The `params` parameter can be an object containing the query options as described [here](https://parse.com/docs/rest#queries-basic). Note that unlike the Parse API Doc, you do not have to pass in strings for the parameter values. This is all taken care of for you.\n\nIf you do not want to pass in some query parameters, you can set the callback as the first parameter.\n\nThe `body` in the callback is an array of the returned objects.\n\n    // get all objects (no parameters)\n    kaiseki.getObjects('Dogs', function(err, res, body) {\n      console.log('all dogs = ', body);\n    });\n\n    // query with parameters\n    var params = {\n      where: { breed: \"Chow Chow\" },\n      order: '-name'\n    };\n    kaiseki.getObjects('Dogs', params, function(err, res, body) {\n      console.log('Chow chow dogs = ', body);\n    });\n\n##### Using `count` with `getObjects`.\n\nYou are allowed to pass in the `count` parameter when using `getObjects`. If you do, the value of `body` will be an object with the properties `results` and `count`. The `results` property contains the objects resulting from the query. See more about counting [here](https://parse.com/docs/rest#queries-counting). If you only need `count`, you may also use the helper method `countObjects`. Using `getObjects` for counting has the advantage of querying for a _limited_ list of objects and getting the total possible objects that can be queried at the same time.\n\n    // Get 10 objects, but also return the total number of objects\n    var params = {\n      where: { breed: \"Chow Chow\" },\n      limit: 10,\n      count: true\n    };\n    kaiseki.getObjects('Dogs', params, function(err, res, body) {\n      console.log('The first 10 Chow chow dogs = ', body.results);\n      console.log('Total number of Chow chow dogs = ', body.count);\n    });\n\n#### countObjects (className, params, callback)\n\nSame as getObjects but returns a count in the `body.count` parameter without returning any objects.\n\n    // count all objects (no parameters)\n    kaiseki.countObjects('Dogs', function(err, res, body) {\n      console.log('number of dogs = ', body.count);\n    });\n\n    // query with parameters\n    var params = {\n      where: { breed: \"Chow Chow\" },\n      order: '-name'\n    };\n    kaiseki.getObjects('Dogs', params, function(err, res, body) {\n      console.log('Number of Chow chow dogs = ', body.count);\n    });\n\n### Roles\n\nRole methods are similar to the Object methods except that they don't require you to use a classname.\n\n#### createRole (data, callback)\n\nCreates a role and passes to `body` whatever you passed in `data` plus the returned `createdAt` field. You can only create a role if you provide the `kaiseki.masterKey` property.\n\n    var data = {\n      name: 'Administrator',\n      ACL: {\n          \"*\": {\n            \"read\": true\n          }\n        },\n      roles: {\n          \"__op\": \"AddRelation\",\n          \"objects\": [\n            {\n              \"__type\": \"Pointer\",\n              \"className\": \"_Role\",\n              \"objectId\": <role-id>\n            }\n          ]\n        },\n      users: {\n          \"__op\": \"AddRelation\",\n          \"objects\": [\n            {\n              \"__type\": \"Pointer\",\n              \"className\": \"_User\",\n              \"objectId\": <user-id>\n            }\n          ]\n        }\n    };\n\n    kaiseki.createRole(data, function(err, res, body) {\n      console.log('role created = ', body);\n      console.log('object id = ', body.objectId);\n    });\n\n#### getRole (objectId, params, callback)\n\nGets a role based on the `objectId`. The `params` is currently unused but is there for a future use. You can pass in the callback function as the second parameter.\n\n    kaiseki.getRole('<object-id>', function(err, res, body) {\n      console.log('found role = ', body);\n    });\n\n#### updateRole (objectId, data, callback)\n\nUpdates a role. If successful, body will contain the `updatedAt` value. You can only update a role if you provide the `kaiseki.masterKey` property or the `kaiseki.sessionToken` property and if that user has write access to the role.\n\n    var data = {\n      users: {\n          \"__op\": \"RemoveRelation\",\n          \"objects\": [\n            {\n              \"__type\": \"Pointer\",\n              \"className\": \"_User\",\n              \"objectId\": <user-id>\n            }\n          ]\n        }\n    };\n\n    kaiseki.updateRole(data, function(err, res, body) {\n      console.log('role updated at = ', body.updatedAt);\n    });\n\n#### deleteRole (objectId, callback)\n\nDeletes a role. The REST API does not return anything in the body so it's best to check for `success` if the operation was successful. You can only delete a role if you provide the `kaiseki.masterKey` property or the `kaiseki.sessionToken` property and if that user has write access to the role.\n\n    kaiseki.deleteRole('<object-id>', function(err, res, body, success) {\n      if (success)\n        console.log('deleted!');\n      else\n        console.log('failed!');\n    });\n\n#### getRoles (params, callback)\n\nReturns an array of roles. The `params` parameter can be an object containing the query options as described [here](https://parse.com/docs/rest#queries-basic). Note that unlike the Parse API Doc, you do not have to pass in strings for the parameter values. This is all taken care for you.\n\nIf you do not want to pass in some query parameters, you can set the callback as the first parameter.\n\nThe `body` in the callback is an array of the returned roles.\n\n    // get all objects (no parameters)\n    kaiseki.getRoles(function(err, res, body) {\n      console.log('all roles = ', body);\n    });\n\n    // query with parameters\n    var params = {\n      where: { name: \"Administrator\" }\n    };\n    kaiseki.getRoles(params, function(err, res, body) {\n      console.log('Administrator Role = ', body);\n    });\n\n### Files\n\n#### uploadFile (filePath, fileName, callback)\n\nUpload a local file. Specifying `fileName` is optional. If successful, the `body` result will contain the Parse `name` and `url` of the file. The value of `name` is what you will use for associating a Parse file to an object.\n\n    var localFilePath = __dirname + '/images/apple.jpg';\n    kaiseki.uploadFile(localFilePath, function(err, res, body, success) {\n      console.log('uploaded file url:', body.url);\n      console.log('uploaded file name:', body.name);\n    });\n\n#### uploadFileBuffer (buffer, contentType, fileName, callback)\n\nThis is a more specific upload utility. You can specify the buffer or string to be used as the upload data. The `body` result is still the same as `uploadFile()`.\n\n    var buffer = require('fs').readFileSync(localFilePath);\n    kaiseki.uploadFileBuffer(buffer, 'image/jpeg', 'orange.jpg', function(err, res, body, success) {\n      console.log('uploaded file details', body);\n    });\n\nUploading a string as a text file:\n\n    var buffer = 'my text file contents';\n    kaiseki.uploadFileBuffer(buffer, 'text/plain', 'readme.txt', function(err, res, body, success) {\n      console.log('uploaded file details', body);\n    });\n\n#### deleteFile (name, callback)\n\nDeleting files require the Parse API master key. The value of `name` should be the name generated by Parse during upload.\n\n    kaiseki.masterKey = 'your-api-master-key';\n    var parseFileName = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx-files.apple.jpg';\n    kaiseki.deleteFile(parseFileName, function(err, res, body, success) {\n      // body is empty here\n      if (success)\n        console.log('successfully deleted file!');\n    });\n\n#### Associating Files with Objects\n\nOnce you have the Parse file `name` after calling `uploadFile()` or `uploadFileBuffer()`, you can attach it to an object by simple setting a `\"File\"` data type to a property. More info [here](https://parse.com/docs/rest#files-associating).\n\n    var parseFileName = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx-files.apple.jpg';\n    var apple = {\n      name: 'Apple',\n      rotten: true,\n      photo: {\n        name: parseFileName,\n        __type: 'File'\n      }\n    };\n    kaiseki.createObject('Fruits', apple, function(err, res, body, success) {\n      if (success)\n        console.log('created an apple object with image');\n    });\n\nAssociating a file to an existing object:\n\n    var orange = {\n      photo: {\n        name: parseFileName,\n        __type: 'File'\n      }\n    };\n    kaiseki.updateObject('Fruits', 'the-object-id', orange, function(err, res, body, success) {\n      if (success)\n        console.log('attached photo to an object');\n    });\n\n### Push Notifications\n\n#### sendPushNotification (data, callback)\n\nSend a push notification. The `data` parameter has to follow the data structure as described in the [Parse REST API](https://www.parse.com/docs/rest#push). The following code sample sends a notification to the broadcast channel (all devices) on all platforms (iOS and Android).\n\n*Please note:* For push notifications to work you have to configure your Parse app accordingly. Use the _Settings > Push_ section of your app's dashboard.\n\n    var notification = {\n      channels: [''],\n      data: {\n        alert: \"Tune in for the World Series, tonight at 8pm EDT\"\n      }\n    };\n\n    kaiseki.sendPushNotification(notification, function(err, res, body, success) {\n      if (success) {\n        console.log('Push notification successfully sent:', body);\n      } else {\n        console.log('Could not send push notification:', err);\n      }\n    });\n\n### GeoPoints\n\nYou can set [GeoPoints](https://parse.com/docs/rest#geo) by simply setting a `\"GeoPoint\"` data type to a property named `\"location\"`.\n\n    var place = {\n      name: 'Tokyo Coffee Shop',\n      location: {\n        __type: 'GeoPoint',\n        latitude: 40.0,\n        longitude: -30.0\n      }\n    };\n    kaiseki.createObject('Places', place, function(err, res, body, success) {\n      if (success)\n        console.log('Created a place with a GeoPoint.');\n    });\n\nTests\n-------------\nThe tests use [mocha](http://visionmedia.github.com/mocha/) and have to be run on an empty Parse application. Please provide your own API keys in `test/config.js`. To run the test:\n\n    make mocha\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "kaiseki@0.4.0",
  "_from": "kaiseki"
}
